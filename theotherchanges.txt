whether.js from backed routes: "onst express = require('express');
const router = express.Router();
const { verifyToken } = require('../middleware/auth');

const weatherCache = new Map();
const CACHE_DURATION = 30 * 60 * 1000;

const isCacheValid = (timestamp) => {
  return Date.now() - timestamp < CACHE_DURATION;
};

const geocodeLocation = async (location) => {
  const apiKey = process.env.OPENWEATHERMAP_API_KEY;
  if (!apiKey) {
    throw new Error('OpenWeatherMap API key not configured');
  }

  let cleanLocation = location.trim();

  if (!cleanLocation.includes('India') && !cleanLocation.includes('IN')) {
    cleanLocation = `${cleanLocation}, India`;
  }

  const geocodeUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(cleanLocation)}&limit=1&appid=${apiKey}`;
  
  try {
    const response = await fetch(geocodeUrl);
    if (!response.ok) {
      throw new Error(`Geocoding failed: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (!data || data.length === 0) {
      const parts = location.split(',').map(part => part.trim());
      if (parts.length > 1) {
        const fallbackLocation = parts.slice(0, -1).join(', ') + ', India';
        const fallbackUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(fallbackLocation)}&limit=1&appid=${apiKey}`;
        const fallbackResponse = await fetch(fallbackUrl);
        const fallbackData = await fallbackResponse.json();
        
        if (fallbackData && fallbackData.length > 0) {
          return {
            name: fallbackData[0].name,
            lat: fallbackData[0].lat,
            lon: fallbackData[0].lon,
            country: fallbackData[0].country,
            state: fallbackData[0].state
          };
        }
      }
      throw new Error('Location not found');
    }
    
    return {
      name: data[0].name,
      lat: data[0].lat,
      lon: data[0].lon,
      country: data[0].country,
      state: data[0].state
    };
  } catch (error) {
    console.error('Geocoding error:', error);
    throw new Error(`Failed to geocode location: ${error.message}`);
  }
};

const getWeatherData = async (lat, lon, eventDate = null) => {
  const apiKey = process.env.OPENWEATHERMAP_API_KEY;
  
  try {
    const currentWeatherUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`;
    const currentResponse = await fetch(currentWeatherUrl);
    
    if (!currentResponse.ok) {
      throw new Error(`Current weather API failed: ${currentResponse.status}`);
    }
    
    const currentData = await currentResponse.json();
    
    const forecastUrl = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`;
    const forecastResponse = await fetch(forecastUrl);
    
    if (!forecastResponse.ok) {
      throw new Error(`Forecast API failed: ${forecastResponse.status}`);
    }
    
    const forecastData = await forecastResponse.json();
    
    let eventForecast = null;
    if (eventDate) {
      let targetDate;
      if (typeof eventDate === 'string') {
        if (eventDate.match(/^\d{4}-\d{2}-\d{2}$/)) {
          const [year, month, day] = eventDate.split('-');
          targetDate = new Date(parseInt(year), parseInt(month) - 1, parseInt(day), 12, 0, 0);
          console.log('Backend - Parsed YYYY-MM-DD format:', eventDate, '->', targetDate);
        }
        else if (eventDate.includes('/')) {
          const [month, day, year] = eventDate.split('/');
          targetDate = new Date(parseInt(year), parseInt(month) - 1, parseInt(day), 12, 0, 0);
          console.log('Backend - Parsed MM/DD/YYYY format:', eventDate, '->', targetDate);
        }
        else {
          targetDate = new Date(eventDate);
          targetDate.setHours(12, 0, 0, 0);
          console.log('Backend - Parsed fallback format:', eventDate, '->', targetDate);
        }
      } else {
        targetDate = new Date(eventDate);
        targetDate.setHours(12, 0, 0, 0);
        console.log('Backend - Parsed non-string format:', eventDate, '->', targetDate);
      }
      
      targetDate.setHours(12, 0, 0, 0);
      const targetDateStr = targetDate.toISOString().split('T')[0];
      
      console.log('Backend - Received event date:', eventDate);
      console.log('Backend - Parsed target date:', targetDateStr);
      console.log('Backend - Target date object:', targetDate);
      console.log('Backend - Looking for forecast for date:', targetDateStr);
      
      console.log('Backend - Available forecast dates:');
      forecastData.list.forEach((item, index) => {
        const itemDate = new Date(item.dt * 1000);
        const itemDateStr = itemDate.toISOString().split('T')[0];
        const timeDiff = Math.abs(itemDate.getTime() - targetDate.getTime());
        const daysDiff = Math.round(timeDiff / (24 * 60 * 60 * 1000));
        console.log(`  ${index}: ${itemDateStr} (${itemDate.toLocaleDateString()}) - ${daysDiff} days away`);
      });
      
      eventForecast = forecastData.list.find(item => {
        const itemDate = new Date(item.dt * 1000);
        itemDate.setHours(12, 0, 0, 0);
        const itemDateStr = itemDate.toISOString().split('T')[0];
        console.log('Checking exact match:', itemDateStr, 'vs', targetDateStr);
        return itemDateStr === targetDateStr;
      });
      
      if (!eventForecast) {
        console.log('No exact date match found, looking for closest date...');
        const targetTime = targetDate.getTime();
        const oneDayMs = 24 * 60 * 60 * 1000; 
        
        const sortedForecasts = forecastData.list
          .map(item => {
            const itemDate = new Date(item.dt * 1000);
            itemDate.setHours(12, 0, 0, 0);
            return {
              ...item,
              timeDiff: Math.abs(itemDate.getTime() - targetTime)
            };
          })
          .sort((a, b) => a.timeDiff - b.timeDiff);
        
        console.log('Sorted forecasts by time difference:');
        sortedForecasts.slice(0, 5).forEach((item, index) => {
          const itemDate = new Date(item.dt * 1000);
          const itemDateStr = itemDate.toISOString().split('T')[0];
          const daysDiff = Math.round(item.timeDiff / oneDayMs);
          console.log(`  ${index}: ${itemDateStr} (${daysDiff} days away)`);
        });
        
 
        eventForecast = sortedForecasts.find(item => item.timeDiff <= 3 * oneDayMs);
        
        if (eventForecast) {
          const eventDateStr = new Date(eventForecast.dt * 1000).toISOString().split('T')[0];
          const daysDiff = Math.round(eventForecast.timeDiff / oneDayMs);
          console.log('Found closest forecast for date:', eventDateStr, `(${daysDiff} days away)`);
        } else {
          console.log('No forecast found within 3 days of target date');
          console.log('Target date:', targetDateStr);
          console.log('Available dates:', forecastData.list.map(item => {
            const itemDate = new Date(item.dt * 1000);
            return itemDate.toISOString().split('T')[0];
          }));
        }
      } else {
        console.log('Found exact forecast match');
      }
    }
    
    if (!eventForecast && eventDate && forecastData.list.length > 0) {
      console.log('Using first available forecast as fallback');
      eventForecast = forecastData.list[0];
    }

    return {
      current: {
        temperature: Math.round(currentData.main.temp),
        feelsLike: Math.round(currentData.main.feels_like),
        condition: currentData.weather[0].main,
        description: currentData.weather[0].description,
        icon: currentData.weather[0].icon,
        humidity: currentData.main.humidity,
        windSpeed: Math.round(currentData.wind.speed * 3.6), // Convert m/s to km/h
        pressure: currentData.main.pressure
      },
      forecast: eventForecast ? {
        temperature: Math.round(eventForecast.main.temp),
        feelsLike: Math.round(eventForecast.main.feels_like),
        condition: eventForecast.weather[0].main,
        description: eventForecast.weather[0].description,
        icon: eventForecast.weather[0].icon,
        humidity: eventForecast.main.humidity,
        windSpeed: Math.round(eventForecast.wind.speed * 3.6),
        time: new Date(eventForecast.dt * 1000).toLocaleTimeString('en-US', { 
          hour: '2-digit', 
          minute: '2-digit' 
        }),
        date: new Date(eventForecast.dt * 1000).toLocaleDateString('en-US', {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        })
      } : null,
      location: {
        name: currentData.name,
        country: currentData.sys.country
      }
    };
  } catch (error) {
    console.error('Weather API error:', error);
    throw new Error(`Failed to fetch weather data: ${error.message}`);
  }
};

// GET /api/weather/:location
router.get('/weather/:location', verifyToken, async (req, res) => {
  try {
    const { location } = req.params;
    const { eventDate } = req.query;
    
    console.log('Weather API called with:');
    console.log('  Location:', location);
    console.log('  Event Date:', eventDate);
    console.log('  Event Date Type:', typeof eventDate);
    
    if (!location) {
      return res.status(400).json({
        error: 'Location required',
        message: 'Please provide a location parameter'
      });
    }
    
    // Check cache first
    const cacheKey = `${location}:${eventDate || 'current'}`;
    const cachedData = weatherCache.get(cacheKey);
    
    if (cachedData && isCacheValid(cachedData.timestamp)) {
      console.log('Returning cached weather data for:', location);
      return res.json({
        success: true,
        data: cachedData.data,
        cached: true
      });
    }
    
    console.log('Fetching fresh weather data for:', location);
    
    // Geocode location
    const geocodedLocation = await geocodeLocation(location);
    
    // Get weather data
    const weatherData = await getWeatherData(
      geocodedLocation.lat, 
      geocodedLocation.lon, 
      eventDate
    );
    
    // Add location info to response
    const responseData = {
      ...weatherData,
      location: {
        ...weatherData.location,
        original: location,
        geocoded: geocodedLocation
      }
    };
    
    // Cache the result
    weatherCache.set(cacheKey, {
      data: responseData,
      timestamp: Date.now()
    });
    
    // Clean old cache entries (simple cleanup)
    if (weatherCache.size > 100) {
      const now = Date.now();
      for (const [key, value] of weatherCache.entries()) {
        if (!isCacheValid(value.timestamp)) {
          weatherCache.delete(key);
        }
      }
    }
    
    res.json({
      success: true,
      data: responseData,
      cached: false
    });
    
  } catch (error) {
    console.error('Weather API error:', error);
    res.status(500).json({
      error: 'Weather service error',
      message: error.message
    });
  }
});

module.exports = router;"

On server.js backend: "const freelancerRoutes = require('./routes/freelancer');
const providerFreelancerRoutes = require('./routes/provider-freelancer');
const staffJobsRoutes = require('./routes/staff-jobs');
const weatherRoutes = require('./routes/weather');
// const searchRoutes = require('./routes/search'); // MySQL routes - disabled

// Firebase helpers already imported above

// Routes
app.get('/', (req, res) => {
  res.json({ 
    message: 'Eventrra Backend API is running!',
    version: '1.0.0',
    timestamp: new Date().toISOString(),
    features: [
      'User Authentication & Role Management',
      'Real-time Bidding & Booking System',
      'Portfolio Management (Instagram-like)',
      'Real-time Notifications',
      'Admin Dashboard',
      'Firebase Integration'
    ]
  });
});

// API Routes
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'OK',
    message: 'Server is healthy',
    uptime: process.uptime(),
    firebase: !!firebaseApp
  });
});

// Mount route handlers
app.use('/api/users', userRoutes);
app.use('/api/bookings', bookingRoutes);
app.use('/api/portfolio', portfolioRoutes);
app.use('/api/notifications', notificationRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/chat', chatRoutes);
app.use('/api/calling', callingRoutes);
app.use('/api/social', socialRoutes);
app.use('/api/testimonials', testimonialRoutes);
app.use('/api/services', serviceRoutes);
app.use('/api/freelancer', freelancerRoutes);
app.use('/api/provider-freelancer', providerFreelancerRoutes);
app.use('/api/staff-jobs', staffJobsRoutes);
app.use('/api', weatherRoutes);"

on frontend,src,js api.js: " async get(endpoint, options = {}) {
    // Handle query parameters
    let finalEndpoint = endpoint;
    if (options.params) {
      const queryString = new URLSearchParams(options.params).toString();
      finalEndpoint = `${endpoint}${queryString ? `?${queryString}` : ''}`;
    }
    
    // Remove params from options before making request
    const { params, ...requestOptions } = options;
    
    return this.request(finalEndpoint, { ...requestOptions, method: 'GET' });
  }

  // POST request
  async post(endpoint, data, options = {}) {
    return this.request(endpoint, {
      ...options,
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  // PUT request
  async put(endpoint, data, options = {}) {
    return this.request(endpoint, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  // PATCH request
  async patch(endpoint, data, options = {}) {
    return this.request(endpoint, {
      ...options,
      method: 'PATCH',
      body: JSON.stringify(data),
    });
  }

  // DELETE request
  async delete(endpoint, options = {}) {
    return this.request(endpoint, { ...options, method: 'DELETE' });
  }
}

// Create a singleton instance
const apiClient = new ApiClient();

// API functions
export const api = {
  // Health check
  health: () => apiClient.get('/health'),
  
  // Firebase status
  firebaseStatus: () => apiClient.get('/firebase/status'),
  
  // User management
  createUserProfile: (role, profileData, uid, email, name, picture) => apiClient.post('/users/register', { uid, email, name, picture, role, profileData }),
  getUserProfile: () => apiClient.get('/users/profile'),
  updateUserProfile: (profileData) => apiClient.put('/users/profile', profileData),
  uploadProfilePicture: (formData) => apiClient.post('/users/profile/picture', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  }),
  
  // Bid requests and bookings
  createBidRequest: (bidData) => apiClient.post('/bookings/bid-request', bidData),
  getBidRequests: (params) => apiClient.get('/bookings/bid-requests', { params }),
  getProviderBidRequests: (params) => apiClient.get('/bookings/provider-bid-requests', { params }),
  getMyBidRequests: (params) => apiClient.get('/bookings/my-bid-requests', { params }),
  deleteBidRequest: (requestId) => apiClient.delete(`/bookings/bid-request/${requestId}`),
  submitBid: (requestId, bidData) => apiClient.post(`/bookings/bid-request/${requestId}/bid`, bidData),
  acceptBid: (requestId, bidId) => apiClient.patch(`/bookings/bid-request/${requestId}/bid/${bidId}`, { action: 'accept' }),
  rejectBid: (requestId, bidId) => apiClient.patch(`/bookings/bid-request/${requestId}/bid/${bidId}`, { action: 'reject' }),
  getBookings: (params) => apiClient.get('/bookings/bookings', { params }),
  updateBookingStatus: (bookingId, status, notes) => apiClient.patch(`/bookings/bookings/${bookingId}/status`, { status, notes }),
  bookNow: (bookingData) => apiClient.post('/bookings/book-now', bookingData),
  acceptBooking: (bookingId, notes) => apiClient.patch(`/bookings/bookings/${bookingId}/status`, { status: 'accepted', notes }),
  declineBooking: (bookingId, notes) => apiClient.patch(`/bookings/bookings/${bookingId}/status`, { status: 'declined', notes }),
  
  // Portfolio management
  uploadPortfolio: (formData) => apiClient.post('/portfolio/upload', formData),
  getPortfolio: (params) => apiClient.get('/portfolio', { params }),
  getMyPortfolio: (params) => apiClient.get('/portfolio/my-portfolio', { params }),
  likePortfolio: (portfolioId) => apiClient.post(`/portfolio/${portfolioId}/like`),
  commentPortfolio: (portfolioId, comment) => apiClient.post(`/portfolio/${portfolioId}/comment`, { comment }),
  deletePortfolio: (portfolioId) => apiClient.delete(`/portfolio/${portfolioId}`),
  getPortfolioStats: (providerId) => apiClient.get(`/portfolio/${providerId}/stats`),
  
  // Notifications
  getNotifications: (params) => apiClient.get('/notifications', { params }),
  markNotificationRead: (notificationId) => apiClient.patch(`/notifications/${notificationId}/read`),
  markAllNotificationsRead: () => apiClient.patch('/notifications/mark-all-read'),
  deleteNotification: (notificationId) => apiClient.delete(`/notifications/${notificationId}`),
  getNotificationCount: () => apiClient.get('/notifications/count'),
  
  // Admin functions
  getDashboardStats: () => apiClient.get('/admin/dashboard'),
  getPendingApprovals: (params) => apiClient.get('/admin/pending-approvals', { params }),
  getAdminUsers: (params) => apiClient.get('/admin/users', { params }),
  getAdminUserById: (userId) => apiClient.get(`/users/${userId}`),
  approveUser: (userId, reason) => apiClient.patch(`/users/${userId}/approval`, { approved: true, reason }),
  rejectUser: (userId, reason) => apiClient.patch(`/users/${userId}/approval`, { approved: false, reason }),
  getAdminBookings: (params) => apiClient.get('/admin/bookings', { params }),
  getAdminBidRequests: (params) => apiClient.get('/admin/bid-requests', { params }),
  getReportedContent: (params) => apiClient.get('/admin/reported-content', { params }),
  handleReport: (reportId, action, reason) => apiClient.patch(`/admin/reports/${reportId}`, { action, reason }),
  getAnalytics: (period) => apiClient.get('/admin/analytics', { params: { period } }),
  
  // Chat functionality
  chat: {
    createChatRoom: (participantId, type) => apiClient.post('/chat/room', { participantId, type }),
    createOrGetRoom: (participantId, type = 'direct') => apiClient.post('/chat/room', { participantId, type }),
    sendMessage: (messageData) => apiClient.post('/chat/message', messageData),
    getChatMessages: (roomId, page, limit) => apiClient.get(`/chat/room/${roomId}/messages`, { params: { page, limit } }),
    getChatRooms: (page, limit) => apiClient.get('/chat/rooms', { params: { page, limit } }),
    getAvailablePartners: () => apiClient.get('/chat/available-partners'),
    getUsersForMessaging: () => apiClient.get('/users/for-messaging'),
    markMessagesRead: (roomId) => apiClient.patch(`/chat/room/${roomId}/read`),
    getOnlineUsers: () => apiClient.get('/chat/online-users'),
    uploadMedia: (formData) => apiClient.post('/chat/upload-media', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
      skipAuth: false
    })
  },

  // Legacy chat methods (for backward compatibility)
  createChatRoom: (participantId, type) => apiClient.post('/chat/room', { participantId, type }),
  createOrGetRoom: (participantId, type = 'direct') => apiClient.post('/chat/room', { participantId, type }),
  sendMessage: (messageData) => apiClient.post('/chat/message', messageData),
  getChatMessages: (roomId, page, limit) => apiClient.get(`/chat/room/${roomId}/messages`, { params: { page, limit } }),
  getChatRooms: (page, limit) => apiClient.get('/chat/rooms', { params: { page, limit } }),
  getAvailablePartners: () => apiClient.get('/chat/available-partners'),
  getUsersForMessaging: () => apiClient.get('/users/for-messaging'),
  markMessagesRead: (roomId) => apiClient.patch(`/chat/room/${roomId}/read`),
  getOnlineUsers: () => apiClient.get('/chat/online-users'),
  uploadMedia: (formData) => apiClient.post('/chat/upload-media', formData, {
    headers: { 'Content-Type': 'multipart/form-data' },
    skipAuth: false
  }),

  // Calling functionality
  initiateCall: (recipientId, type) => apiClient.post('/calling/initiate', { recipientId, type }),
  acceptCall: (callId) => apiClient.post(`/calling/accept/${callId}`),
  rejectCall: (callId, reason) => apiClient.post(`/calling/reject/${callId}`, { reason }),
  endCall: (callId) => apiClient.post(`/calling/end/${callId}`),
  getCallHistory: (page, limit, type, status) => apiClient.get('/calling/history', { params: { page, limit, type, status } }),
  getWebRTCConfig: () => apiClient.get('/calling/webrtc-config'),
  getCallStats: (period) => apiClient.get('/calling/stats', { params: { period } }),

  // Social feed functionality
  createPost: (content, media, type, tags, location) => apiClient.post('/social/post', { content, media, type, tags, location }),
  getFeed: (page, limit, type, userId) => apiClient.get('/social/feed', { params: { page, limit, type, userId } }),
  likePost: (postId) => apiClient.post(`/social/post/${postId}/like`),
  commentPost: (postId, content) => apiClient.post(`/social/post/${postId}/comment`, { content }),
  sharePost: (postId) => apiClient.post(`/social/post/${postId}/share`),
  getUserPosts: (userId, page, limit) => apiClient.get(`/social/user/${userId}/posts`, { params: { page, limit } }),
  deletePost: (postId) => apiClient.delete(`/social/post/${postId}`),
  getTrendingPosts: (period) => apiClient.get('/social/trending', { params: { period } }),
  searchPosts: (query, type, tags, page, limit) => apiClient.get('/social/search', { params: { query, type, tags, page, limit } }),

  // Weather functionality
  getWeather: (location, eventDate = null) => {
    const params = eventDate ? { eventDate } : {};
    console.log('API - getWeather called with:');
    console.log('  Location:', location);
    console.log('  Event Date:', eventDate);
    console.log('  Event Date Type:', typeof eventDate);
    console.log('  Params:', params);
    
    // Build the URL manually to see what's being sent
    const baseUrl = `/weather/${encodeURIComponent(location)}`;
    const queryString = params.eventDate ? `?eventDate=${encodeURIComponent(params.eventDate)}` : '';
    const fullUrl = `${baseUrl}${queryString}`;
    console.log('  Full URL:', fullUrl);
    
    return apiClient.get(`/weather/${encodeURIComponent(location)}`, { params });
  },"

  atlast the api on env:"# Weather API
OPENWEATHERMAP_API_KEY=0eda69c968cd2fd1def2e50a202cc3fe"